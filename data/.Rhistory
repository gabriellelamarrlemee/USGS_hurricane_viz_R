}
new
new$dateTime <- as.POSIXct(new$dateTime)
new$dateTime <- as.POSIXct(new$dateTime, origin = "1960-01-01")
View(new)
streamdata_time <- rbind(streamdata_time, new)
server <- function(input, output, session) {
precipColor <- colorBin(palette = c('#edf5e5', '#bcdec9', '#aec8d5', '#8c6bb1', '#9c90ba', '#5d426d', '#361e44'),
bins = 7, pretty = TRUE,
domain = precip_merge$precip)
output$map <- renderLeaflet({ # Build map
leaflet(options = leafletOptions(zoomControl=FALSE, height="100vh")) %>%
addProviderTiles(providers$Esri.WorldTopoMap,
options = providerTileOptions(opacity = 1)) %>%
setView(lng=-76.1637, lat=33.8361, zoom=7) %>%
addMinicharts(lng = streamdata_time$dec_long_va,
lat = streamdata_time$dec_lat_va,
layerId = streamdata_time$site_no,
type = "bar")
})
observe({ # Add precip polygons
leafletProxy("map", data = subset(precip_merge, time == input$time)) %>%
removeShape(s) %>%
addPolygons(color = ~precipColor(precip), weight = 0,
smoothFactor = 0.5, opacity = 1.0, fillOpacity = 0.75, layerId=~id)
s <<- subset(precip_merge, time == input$time)$id
# cat(file=stderr(), "debug ", s, "\n")
})
# observe({ # Add gages
#     leafletProxy("map", data = subset(streamdata_time, dateTime == input$time)) %>%
#         addCircles(lng = ~dec_long_va,
#                    lat = ~dec_lat_va,
#                    weight = ~flood_norm * 10,
#                    color = "blue",
#                    fillOpacity = 0.15,
#                    radius = 20, popup = ~station_nm, layerId=~station_nm)
# })
#
#
# observe({ # Add gages
#     leafletProxy("map", data = gages_filtered) %>%
#         addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#                    color = "blue", fillOpacity = 1,
#                    radius = 20, popup = ~station_nm)
# })
#
observe({ # Add gages
data <- subset(streamdata_time, dateTime == input$time)
leafletProxy("map") %>%
addMinicharts(
layerId = data$site_no,
chartdata = data$flood_norm
)
# addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#            color = "blue", fillOpacity = 1,
#            radius = 20, popup = ~station_nm)
})
observe({ # Add hurricane path
for (i in unique(pts_wgs84_groups$group)) {
group_sub <- pts_wgs84_groups[which(pts_wgs84_groups$group == i), ]
if(group_sub[2,]$dateTime <= input$time) {
leafletProxy("map", data = group_sub) %>%
addPolylines(lng = ~LON, lat = ~LAT, weight = ~INTENSITY/10,
popup = ~STORMTYPE, layerId=~dateTime, opacity = 1.0)
}
}
})
observe({
input$time # Update the time series to align with the map
updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
output$graph <- renderDygraph({
dygraph(updated, main = "Water level at selected USGS gages", width = '270', height = '700') %>%
dyAxis("y", valueRange = c(-18,50), axisLabelWidth = 20) %>%
dyAxis("x", drawGrid = FALSE) %>%
dyRangeSelector(dateWindow = c("2018-09-12 00:00:00", "2018-09-19 11:00:00"), height = 20) %>%
dyLegend(show="never") %>%
dyOptions(colors = '#000', drawGrid = FALSE) %>%
dyShading(from = "-20", to = "0", color = "#EFEFEF", axis = "y")
})
})
# Add interaction events
observeEvent(input$graph_click$x, { # This could identify which line goes to which gage (also on hover)
cat(file=stderr(), "debug ", input$graph_click$series, "\n")
# on our click let's update the dygraph to only show the time series for the clicked
# updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
# output$graph <- renderDygraph({
#     dygraph(updated, main = "Water at selected USGS gages", width = '270', height = '700') %>%
#         dyAxis("y", valueRange = c(-18,50)) %>%
#         dyRangeSelector(dateWindow = c("2018-09-11 04:00:00", "2018-09-19 14:00:00"), height = 20) %>%
#         dyLegend(show="never") %>%
#         dyOptions(colors = '#000')
# })
})
}
shinyApp(ui, server)
View(gages)
streamdata_time <- merge(streamdata_filtered, gages_filtered, by="site_no")
new <- data.frame(matrix(ncol = 8, nrow = 0))
columns <- c("site_no", "dateTime", "X_00065_00000", "flood_norm", "station_nm", "dec_lat_va", "dec_long_va", "flood_stage")
colnames(new) <- columns
for (i in unique(streamdata_time$dateTime)) {
for(a in unique(streamdata_time$site_no)) {
if(nrow(subset(streamdata_time, dateTime == i & site_no == a))==0) {
gage <- subset(gages, site_no == a)
row <- c(a, i, NA, NA, NA, gage$dec_lat_va, gage$dec_lat_va, NA)
new[nrow(new)+1,] <- row
}
}
}
new$dateTime <- as.POSIXct(new$dateTime, origin = "1960-01-01")
streamdata_time <- rbind(streamdata_time, new)
streamdata_time <- merge(streamdata_filtered, gages_filtered, by="site_no")
new <- data.frame(matrix(ncol = 8, nrow = 0))
columns <- c("site_no", "dateTime", "X_00065_00000", "flood_norm", "station_nm", "dec_lat_va", "dec_long_va", "flood_stage")
colnames(new) <- columns
for (i in unique(streamdata_time$dateTime)) {
for(a in unique(streamdata_time$site_no)) {
if(nrow(subset(streamdata_time, dateTime == i & site_no == a))==0) {
gage <- subset(gages, site_no == a)
row <- c(a, i, NA, NA, NA, gage$dec_lat_va, gage$dec_long_va, NA)
new[nrow(new)+1,] <- row
}
}
}
new$dateTime <- as.POSIXct(new$dateTime, origin = "1960-01-01")
streamdata_time <- rbind(streamdata_time, new)
server <- function(input, output, session) {
precipColor <- colorBin(palette = c('#edf5e5', '#bcdec9', '#aec8d5', '#8c6bb1', '#9c90ba', '#5d426d', '#361e44'),
bins = 7, pretty = TRUE,
domain = precip_merge$precip)
output$map <- renderLeaflet({ # Build map
leaflet(options = leafletOptions(zoomControl=FALSE, height="100vh")) %>%
addProviderTiles(providers$Esri.WorldTopoMap,
options = providerTileOptions(opacity = 1)) %>%
setView(lng=-76.1637, lat=33.8361, zoom=7) %>%
addMinicharts(lng = streamdata_time$dec_long_va,
lat = streamdata_time$dec_lat_va,
layerId = streamdata_time$site_no,
type = "bar")
})
observe({ # Add precip polygons
leafletProxy("map", data = subset(precip_merge, time == input$time)) %>%
removeShape(s) %>%
addPolygons(color = ~precipColor(precip), weight = 0,
smoothFactor = 0.5, opacity = 1.0, fillOpacity = 0.75, layerId=~id)
s <<- subset(precip_merge, time == input$time)$id
# cat(file=stderr(), "debug ", s, "\n")
})
# observe({ # Add gages
#     leafletProxy("map", data = subset(streamdata_time, dateTime == input$time)) %>%
#         addCircles(lng = ~dec_long_va,
#                    lat = ~dec_lat_va,
#                    weight = ~flood_norm * 10,
#                    color = "blue",
#                    fillOpacity = 0.15,
#                    radius = 20, popup = ~station_nm, layerId=~station_nm)
# })
#
#
# observe({ # Add gages
#     leafletProxy("map", data = gages_filtered) %>%
#         addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#                    color = "blue", fillOpacity = 1,
#                    radius = 20, popup = ~station_nm)
# })
#
observe({ # Add gages
data <- subset(streamdata_time, dateTime == input$time)
leafletProxy("map") %>%
addMinicharts(
layerId = data$site_no,
chartdata = data$flood_norm
)
# addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#            color = "blue", fillOpacity = 1,
#            radius = 20, popup = ~station_nm)
})
observe({ # Add hurricane path
for (i in unique(pts_wgs84_groups$group)) {
group_sub <- pts_wgs84_groups[which(pts_wgs84_groups$group == i), ]
if(group_sub[2,]$dateTime <= input$time) {
leafletProxy("map", data = group_sub) %>%
addPolylines(lng = ~LON, lat = ~LAT, weight = ~INTENSITY/10,
popup = ~STORMTYPE, layerId=~dateTime, opacity = 1.0)
}
}
})
observe({
input$time # Update the time series to align with the map
updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
output$graph <- renderDygraph({
dygraph(updated, main = "Water level at selected USGS gages", width = '270', height = '700') %>%
dyAxis("y", valueRange = c(-18,50), axisLabelWidth = 20) %>%
dyAxis("x", drawGrid = FALSE) %>%
dyRangeSelector(dateWindow = c("2018-09-12 00:00:00", "2018-09-19 11:00:00"), height = 20) %>%
dyLegend(show="never") %>%
dyOptions(colors = '#000', drawGrid = FALSE) %>%
dyShading(from = "-20", to = "0", color = "#EFEFEF", axis = "y")
})
})
# Add interaction events
observeEvent(input$graph_click$x, { # This could identify which line goes to which gage (also on hover)
cat(file=stderr(), "debug ", input$graph_click$series, "\n")
# on our click let's update the dygraph to only show the time series for the clicked
# updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
# output$graph <- renderDygraph({
#     dygraph(updated, main = "Water at selected USGS gages", width = '270', height = '700') %>%
#         dyAxis("y", valueRange = c(-18,50)) %>%
#         dyRangeSelector(dateWindow = c("2018-09-11 04:00:00", "2018-09-19 14:00:00"), height = 20) %>%
#         dyLegend(show="never") %>%
#         dyOptions(colors = '#000')
# })
})
}
shinyApp(ui, server)
streamdata_time <- merge(streamdata_filtered, gages_filtered, by="site_no")
new <- data.frame(matrix(ncol = 8, nrow = 0))
columns <- c("site_no", "dateTime", "X_00065_00000", "flood_norm", "station_nm", "dec_lat_va", "dec_long_va", "flood_stage")
colnames(new) <- columns
for (i in unique(streamdata_time$dateTime)) {
for(a in unique(streamdata_time$site_no)) {
if(nrow(subset(streamdata_time, dateTime == i & site_no == a))==0) {
gage <- subset(gages, site_no == a)
row <- c(a, i, NA, NA, NA, gage$dec_lat_va, gage$dec_long_va, 0)
new[nrow(new)+1,] <- row
}
}
}
new$dateTime <- as.POSIXct(new$dateTime, origin = "1960-01-01")
streamdata_time <- rbind(streamdata_time, new)
server <- function(input, output, session) {
precipColor <- colorBin(palette = c('#edf5e5', '#bcdec9', '#aec8d5', '#8c6bb1', '#9c90ba', '#5d426d', '#361e44'),
bins = 7, pretty = TRUE,
domain = precip_merge$precip)
output$map <- renderLeaflet({ # Build map
leaflet(options = leafletOptions(zoomControl=FALSE, height="100vh")) %>%
addProviderTiles(providers$Esri.WorldTopoMap,
options = providerTileOptions(opacity = 1)) %>%
setView(lng=-76.1637, lat=33.8361, zoom=7) %>%
addMinicharts(lng = streamdata_time$dec_long_va,
lat = streamdata_time$dec_lat_va,
layerId = streamdata_time$site_no,
type = "bar")
})
observe({ # Add precip polygons
leafletProxy("map", data = subset(precip_merge, time == input$time)) %>%
removeShape(s) %>%
addPolygons(color = ~precipColor(precip), weight = 0,
smoothFactor = 0.5, opacity = 1.0, fillOpacity = 0.75, layerId=~id)
s <<- subset(precip_merge, time == input$time)$id
# cat(file=stderr(), "debug ", s, "\n")
})
# observe({ # Add gages
#     leafletProxy("map", data = subset(streamdata_time, dateTime == input$time)) %>%
#         addCircles(lng = ~dec_long_va,
#                    lat = ~dec_lat_va,
#                    weight = ~flood_norm * 10,
#                    color = "blue",
#                    fillOpacity = 0.15,
#                    radius = 20, popup = ~station_nm, layerId=~station_nm)
# })
#
#
# observe({ # Add gages
#     leafletProxy("map", data = gages_filtered) %>%
#         addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#                    color = "blue", fillOpacity = 1,
#                    radius = 20, popup = ~station_nm)
# })
#
observe({ # Add gages
data <- subset(streamdata_time, dateTime == input$time)
leafletProxy("map") %>%
addMinicharts(
layerId = data$site_no,
chartdata = data$flood_norm
)
# addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#            color = "blue", fillOpacity = 1,
#            radius = 20, popup = ~station_nm)
})
observe({ # Add hurricane path
for (i in unique(pts_wgs84_groups$group)) {
group_sub <- pts_wgs84_groups[which(pts_wgs84_groups$group == i), ]
if(group_sub[2,]$dateTime <= input$time) {
leafletProxy("map", data = group_sub) %>%
addPolylines(lng = ~LON, lat = ~LAT, weight = ~INTENSITY/10,
popup = ~STORMTYPE, layerId=~dateTime, opacity = 1.0)
}
}
})
observe({
input$time # Update the time series to align with the map
updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
output$graph <- renderDygraph({
dygraph(updated, main = "Water level at selected USGS gages", width = '270', height = '700') %>%
dyAxis("y", valueRange = c(-18,50), axisLabelWidth = 20) %>%
dyAxis("x", drawGrid = FALSE) %>%
dyRangeSelector(dateWindow = c("2018-09-12 00:00:00", "2018-09-19 11:00:00"), height = 20) %>%
dyLegend(show="never") %>%
dyOptions(colors = '#000', drawGrid = FALSE) %>%
dyShading(from = "-20", to = "0", color = "#EFEFEF", axis = "y")
})
})
# Add interaction events
observeEvent(input$graph_click$x, { # This could identify which line goes to which gage (also on hover)
cat(file=stderr(), "debug ", input$graph_click$series, "\n")
# on our click let's update the dygraph to only show the time series for the clicked
# updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
# output$graph <- renderDygraph({
#     dygraph(updated, main = "Water at selected USGS gages", width = '270', height = '700') %>%
#         dyAxis("y", valueRange = c(-18,50)) %>%
#         dyRangeSelector(dateWindow = c("2018-09-11 04:00:00", "2018-09-19 14:00:00"), height = 20) %>%
#         dyLegend(show="never") %>%
#         dyOptions(colors = '#000')
# })
})
}
shinyApp(ui, server)
server <- function(input, output, session) {
precipColor <- colorBin(palette = c('#edf5e5', '#bcdec9', '#aec8d5', '#8c6bb1', '#9c90ba', '#5d426d', '#361e44'),
bins = 7, pretty = TRUE,
domain = precip_merge$precip)
output$map <- renderLeaflet({ # Build map
leaflet(options = leafletOptions(zoomControl=FALSE, height="100vh")) %>%
addProviderTiles(providers$Esri.WorldTopoMap,
options = providerTileOptions(opacity = 1)) %>%
setView(lng=-76.1637, lat=33.8361, zoom=7) %>%
addMinicharts(lng = streamdata_time$dec_long_va,
lat = streamdata_time$dec_lat_va,
layerId = streamdata_time$site_no,
type = "bar")
})
observe({ # Add precip polygons
leafletProxy("map", data = subset(precip_merge, time == input$time)) %>%
removeShape(s) %>%
addPolygons(color = ~precipColor(precip), weight = 0,
smoothFactor = 0.5, opacity = 1.0, fillOpacity = 0.75, layerId=~id)
s <<- subset(precip_merge, time == input$time)$id
# cat(file=stderr(), "debug ", s, "\n")
})
# observe({ # Add gages
#     leafletProxy("map", data = subset(streamdata_time, dateTime == input$time)) %>%
#         addCircles(lng = ~dec_long_va,
#                    lat = ~dec_lat_va,
#                    weight = ~flood_norm * 10,
#                    color = "blue",
#                    fillOpacity = 0.15,
#                    radius = 20, popup = ~station_nm, layerId=~station_nm)
# })
#
#
# observe({ # Add gages
#     leafletProxy("map", data = gages_filtered) %>%
#         addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#                    color = "blue", fillOpacity = 1,
#                    radius = 20, popup = ~station_nm)
# })
#
observe({ # Add gages
data <- subset(streamdata_time, dateTime == input$time)
leafletProxy("map") %>%
addMinicharts(
layerId = data$site_no,
chartdata = data$flood_norm
)
# addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#            color = "blue", fillOpacity = 1,
#            radius = 20, popup = ~station_nm)
})
observe({ # Add hurricane path
for (i in unique(pts_wgs84_groups$group)) {
group_sub <- pts_wgs84_groups[which(pts_wgs84_groups$group == i), ]
if(group_sub[2,]$dateTime <= input$time) {
leafletProxy("map", data = group_sub) %>%
addPolylines(lng = ~LON, lat = ~LAT, weight = ~INTENSITY/10,
popup = ~STORMTYPE, layerId=~dateTime, opacity = 1.0)
}
}
})
observe({
input$time # Update the time series to align with the map
updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
output$graph <- renderDygraph({
dygraph(updated, main = "Water level at selected USGS gages", width = '270', height = '700') %>%
dyAxis("y", valueRange = c(-18,50), axisLabelWidth = 20) %>%
dyAxis("x", drawGrid = FALSE) %>%
dyRangeSelector(dateWindow = c("2018-09-16 00:00:00", "2018-09-19 11:00:00"), height = 20) %>%
dyLegend(show="never") %>%
dyOptions(colors = '#000', drawGrid = FALSE) %>%
dyShading(from = "-20", to = "0", color = "#EFEFEF", axis = "y")
})
})
# Add interaction events
observeEvent(input$graph_click$x, { # This could identify which line goes to which gage (also on hover)
cat(file=stderr(), "debug ", input$graph_click$series, "\n")
# on our click let's update the dygraph to only show the time series for the clicked
# updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
# output$graph <- renderDygraph({
#     dygraph(updated, main = "Water at selected USGS gages", width = '270', height = '700') %>%
#         dyAxis("y", valueRange = c(-18,50)) %>%
#         dyRangeSelector(dateWindow = c("2018-09-11 04:00:00", "2018-09-19 14:00:00"), height = 20) %>%
#         dyLegend(show="never") %>%
#         dyOptions(colors = '#000')
# })
})
}
shinyApp(ui, server)
streamdata_time <- merge(streamdata_filtered, gages_filtered, by="site_no")
new <- data.frame(matrix(ncol = 8, nrow = 0))
columns <- c("site_no", "dateTime", "X_00065_00000", "flood_norm", "station_nm", "dec_lat_va", "dec_long_va", "flood_stage")
colnames(new) <- columns
for (i in unique(streamdata_time$dateTime)) {
for(a in unique(streamdata_time$site_no)) {
if(nrow(subset(streamdata_time, dateTime == i & site_no == a))==0) {
gage <- subset(gages, site_no == a)
row <- c(a, i, NA, NA, NA, gage$dec_lat_va, gage$dec_long_va, 0)
new[nrow(new)+1,] <- row
}
}
}
new$dateTime <- as.POSIXct(new$dateTime, origin = "1970-01-01")
streamdata_time <- rbind(streamdata_time, new)
server <- function(input, output, session) {
precipColor <- colorBin(palette = c('#edf5e5', '#bcdec9', '#aec8d5', '#8c6bb1', '#9c90ba', '#5d426d', '#361e44'),
bins = 7, pretty = TRUE,
domain = precip_merge$precip)
output$map <- renderLeaflet({ # Build map
leaflet(options = leafletOptions(zoomControl=FALSE, height="100vh")) %>%
addProviderTiles(providers$Esri.WorldTopoMap,
options = providerTileOptions(opacity = 1)) %>%
setView(lng=-76.1637, lat=33.8361, zoom=7) %>%
addMinicharts(lng = streamdata_time$dec_long_va,
lat = streamdata_time$dec_lat_va,
layerId = streamdata_time$site_no,
type = "bar")
})
observe({ # Add precip polygons
leafletProxy("map", data = subset(precip_merge, time == input$time)) %>%
removeShape(s) %>%
addPolygons(color = ~precipColor(precip), weight = 0,
smoothFactor = 0.5, opacity = 1.0, fillOpacity = 0.75, layerId=~id)
s <<- subset(precip_merge, time == input$time)$id
# cat(file=stderr(), "debug ", s, "\n")
})
# observe({ # Add gages
#     leafletProxy("map", data = subset(streamdata_time, dateTime == input$time)) %>%
#         addCircles(lng = ~dec_long_va,
#                    lat = ~dec_lat_va,
#                    weight = ~flood_norm * 10,
#                    color = "blue",
#                    fillOpacity = 0.15,
#                    radius = 20, popup = ~station_nm, layerId=~station_nm)
# })
#
#
# observe({ # Add gages
#     leafletProxy("map", data = gages_filtered) %>%
#         addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#                    color = "blue", fillOpacity = 1,
#                    radius = 20, popup = ~station_nm)
# })
#
observe({ # Add gages
data <- subset(streamdata_time, dateTime == input$time)
leafletProxy("map") %>%
addMinicharts(
layerId = data$site_no,
chartdata = data$flood_norm
)
# addCircles(lng = ~dec_long_va, lat = ~dec_lat_va, weight = 5,
#            color = "blue", fillOpacity = 1,
#            radius = 20, popup = ~station_nm)
})
observe({ # Add hurricane path
for (i in unique(pts_wgs84_groups$group)) {
group_sub <- pts_wgs84_groups[which(pts_wgs84_groups$group == i), ]
if(group_sub[2,]$dateTime <= input$time) {
leafletProxy("map", data = group_sub) %>%
addPolylines(lng = ~LON, lat = ~LAT, weight = ~INTENSITY/10,
popup = ~STORMTYPE, layerId=~dateTime, opacity = 1.0)
}
}
})
observe({
input$time # Update the time series to align with the map
updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
output$graph <- renderDygraph({
dygraph(updated, main = "Water level at selected USGS gages", width = '270', height = '700') %>%
dyAxis("y", valueRange = c(-18,50), axisLabelWidth = 20) %>%
dyAxis("x", drawGrid = FALSE) %>%
dyRangeSelector(dateWindow = c("2018-09-16 00:00:00", "2018-09-19 11:00:00"), height = 20) %>%
dyLegend(show="never") %>%
dyOptions(colors = '#000', drawGrid = FALSE) %>%
dyShading(from = "-20", to = "0", color = "#EFEFEF", axis = "y")
})
})
# Add interaction events
observeEvent(input$graph_click$x, { # This could identify which line goes to which gage (also on hover)
cat(file=stderr(), "debug ", input$graph_click$series, "\n")
# on our click let's update the dygraph to only show the time series for the clicked
# updated <- stream_ts[paste('2018/',as.Date(input$time),sep="")]
# output$graph <- renderDygraph({
#     dygraph(updated, main = "Water at selected USGS gages", width = '270', height = '700') %>%
#         dyAxis("y", valueRange = c(-18,50)) %>%
#         dyRangeSelector(dateWindow = c("2018-09-11 04:00:00", "2018-09-19 14:00:00"), height = 20) %>%
#         dyLegend(show="never") %>%
#         dyOptions(colors = '#000')
# })
})
}
shinyApp(ui, server)
